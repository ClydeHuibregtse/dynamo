#!/usr/bin/env python

import sys
import os
import logging
import time
import re
import fnmatch

from common.inventory import InventoryManager
from common.transaction import TransactionManager
from common.demand import DemandManager
import common.interface.classes as classes
from detox.main import Detox
from detox.policy import Policy
from detox.policies.site import NonzeroQuota, GroupOccupancy
from detox.policies.replica import BelongsTo
import detox.configuration as detox_config
from dealer.main import Dealer
from dealer.policy import DealerPolicy

import common.configuration as config

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Dynamo')
parser.add_argument('module', metavar = 'MODULE', nargs = '+', help = 'detox and/or dealer.')
parser.add_argument('--store', '-i', metavar = 'CLASS', dest = 'store_cls', default = '', help = 'Store backend class.')
parser.add_argument('--site-source', '-s', metavar = 'CLASS', dest = 'site_source_cls', default = '', help = 'SiteInfoSourceInterface class.')
parser.add_argument('--dataset-source', '-t', metavar = 'CLASS', dest = 'dataset_source_cls', default = '', help = 'DatasetInfoSourceInterface class.')
parser.add_argument('--replica-source', '-r', metavar = 'CLASS', dest = 'replica_source_cls', default = '', help = 'ReplicaInfoSourceInterface class.')
parser.add_argument('--access-history', '-a', metavar = 'CLASS', dest = 'access_history_cls', default = '', help = 'AccessHistoryInterface class.')
parser.add_argument('--lock', '-k', metavar = 'CLASS', dest = 'lock_cls', default = '', help = 'LockInterface class.')
parser.add_argument('--deletion', '-d', metavar = 'CLASS', dest = 'deletion_cls', default = '', help = 'DeletionInterface class.')
parser.add_argument('--copy', '-c', metavar = 'CLASS', dest = 'copy_cls', default = '', help = 'CopyInterface backend class.')
parser.add_argument('--force-inventory-update', '-I', action = 'store_true', dest = 'force_inventory_update', help = 'Force inventory to update.')
parser.add_argument('--detox-policy-stack', '-p', metavar = 'STACKS', dest = 'detox_stacks', nargs = '+', default = ['AnalysisOps/iterative', 'DataOps/static'], help = 'Name of the policy stack. Syntax is <partition>/[<path>:]strategy[/ranking]. If no path is given, policy stack is taken from DYNAMO_BASE/policies/detox/<partition>.txt. If a relative path is provided, a file is searched for in policies/detoxstacks. Recognized strategies are "iterative", "static", and "greedy". Recognized ranking are global-rank (default) and last_update.')
parser.add_argument('--site', '-e', metavar = 'SITE', dest = 'included_sites', nargs = '+', default = [], help = 'List of sites to include. If not specified, all sites in inventory are included. Wildcard is allowed.')
parser.add_argument('--log-level', '-l', metavar = 'LEVEL', dest = 'log_level', default = 'WARNING', help = 'Logging level.')
parser.add_argument('--log-file', '-o', metavar = 'PATH', dest = 'log_file', default = '', help = 'Log output file.')
parser.add_argument('--dry-run', '-D', action = 'store_true', dest = 'dry_run', help = 'Do not make any actual deletion requests or changes to local databases.')
parser.add_argument('--test-run', '-T', action = 'store_true', dest = 'test_run', help = 'Make a test run (results recorded in local database).')

args = parser.parse_args()
sys.argv = []

log_level = getattr(logging, args.log_level.upper())

if args.log_file:
    logging.basicConfig(filename = args.log_file, filemode = 'w', level = log_level)
else:
    logging.basicConfig(level = log_level)

if args.dry_run:
    config.read_only = True

kwd = {}
for cls in ['store', 'site_source', 'dataset_source', 'replica_source']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

inventory_manager = InventoryManager(**kwd)

kwd = {}
for cls in ['deletion', 'copy']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

transaction_manager = TransactionManager(**kwd)

kwd = {}
for cls in ['store', 'access_history', 'lock']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

demand_manager = DemandManager(**kwd)

history = classes.default_interface['history']()

included_sites = None
if len(args.included_sites) != 0:
    # form a regexp (?:pattern1|pattern2|..)
    included_sites = re.compile('(?:' + '|'.join(map(fnmatch.translate, args.included_sites)) + ')')

if 'detox' in args.module:
    # Main detox object
    
    detox = Detox(inventory_manager, transaction_manager, demand_manager, history)
    
    # Set up detox policies
    
    detox_partitions = []
    
    for stack_spec in args.detox_stacks:
        stackdef = stack_spec.split('/')

        partition = stackdef[0]
        policy_cfg = stackdef[1]

        if ':' in policy_cfg:
            stack_path, strategy_str = policy_cfg.split(':')
        else:
            stack_path = partition
            strategy_str = policy_cfg

        if '/' not in stack_path:
            stack_path = os.environ['DYNAMO_BASE'] + '/policies/detox/' + stack_path + '.txt'

        if len(stackdef) > 2:
            ranking = stackdef[2]
        else:
            ranking = 'global-rank'

        try:
            strategy = eval('Policy.ST_' + strategy_str.upper())
        except NameError:
            print 'Unknown strategy', strategy_str
            sys.exit(1)
    
        detox_partitions.append(partition)

        with open(stack_path) as stack_source:
            stack_lines = map(str.strip, stack_source.read().split('\n'))
            il = 0
            while il != len(stack_lines):
                if stack_lines[il] == '' or stack_lines[il].startswith('#'):
                    stack_lines.pop(il)
                else:
                    il += 1
    
        default, rule_stack = Policy.parse_rules(stack_lines)
    
        # currently partition = group
        group = inventory_manager.groups[partition]
        quotas = dict([(site, site.group_quota(group)) for site in inventory_manager.sites.values()])

        if strategy == Policy.ST_ITERATIVE or strategy == Policy.ST_STATIC:
            # Return true if the site is overused for a given partition.
            # Currently partition and group names are identical.
            site_requirement = GroupOccupancy(group, included_sites)

        elif strategy == Policy.ST_GREEDY:
            # True as long as the group has a nonzero quota
            site_requirement = NonzeroQuota(group, included_sites)

        if ranking == 'last_update':
            # last element goes first
            candidate_sort = lambda r_d: [r for r, d in sorted(replicas_demands, key = lambda (r, d): r.dataset.last_update, reverse = True)]
        else:
            candidate_sort = None # use the default (global usage rank)
    
        policy = Policy(default, rule_stack, strategy, quotas, partition = partition, site_requirement = site_requirement, replica_requirement = BelongsTo(group), candidate_sort = candidate_sort)
    
        detox.set_policy(policy)

if 'dealer' in args.module:
    # Main dealer object
    
    dealer = Dealer(inventory_manager, transaction_manager, demand_manager, history)

    group = inventory_manager.groups['AnalysisOps']
    
    site_occupancy = lambda site: site.storage_occupancy(inventory_manager.groups['AnalysisOps'], physical = False)

    def in_analysisops(replica):
        owner = replica.effective_owner()
        return owner is not None and owner.name == 'AnalysisOps'
    
    policy = DealerPolicy(site_occupancy, partition = 'AnalysisOps', in_partition = in_analysisops, group = group, included_sites = included_sites)
    
    dealer.set_policy(policy)


if args.force_inventory_update:
    inventory_manager.update()

if 'detox' in args.module:
    for partition in detox_partitions:
        detox.run(partition = partition, is_test = args.test_run)

if 'dealer' in args.module:
    dealer.run(partition = 'AnalysisOps', is_test = args.test_run)
