#!/usr/bin/env python

import sys
import os
import logging
import time
import re
import fnmatch

from common.inventory import InventoryManager
from common.transaction import TransactionManager
from common.demand import DemandManager
import common.interface.classes as classes
from detox.main import Detox
from detox.policy import Policy
from detox.partitioning import BelongsTo
import detox.configuration as detox_config
from common.dataformat import Site
import common.configuration as config

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Detox')
parser.add_argument('--store', '-i', metavar = 'CLASS', dest = 'store_cls', default = '', help = 'Store backend class.')
parser.add_argument('--site-source', '-s', metavar = 'CLASS', dest = 'site_source_cls', default = '', help = 'SiteInfoSourceInterface class.')
parser.add_argument('--dataset-source', '-t', metavar = 'CLASS', dest = 'dataset_source_cls', default = '', help = 'DatasetInfoSourceInterface class.')
parser.add_argument('--replica-source', '-r', metavar = 'CLASS', dest = 'replica_source_cls', default = '', help = 'ReplicaInfoSourceInterface class.')
parser.add_argument('--access-history', '-a', metavar = 'CLASS', dest = 'access_history_cls', default = '', help = 'AccessHistoryInterface class.')
parser.add_argument('--lock', '-k', metavar = 'CLASS', dest = 'lock_cls', default = '', help = 'LockInterface class.')
parser.add_argument('--deletion', '-d', metavar = 'CLASS', dest = 'deletion_cls', default = '', help = 'DeletionInterface class.')
parser.add_argument('--force-inventory-update', '-I', action = 'store_true', dest = 'force_inventory_update', help = 'Force inventory to update.')
parser.add_argument('--partition', '-p', metavar = 'PARTITIONS', dest = 'partitions', nargs = '+', default = ['AnalysisOps', 'DataOps'], help = 'Name of the partitions. Syntax is <partition>[:<definition name>]. Definition name is translated to path DYNAMO_BASE/policies/detox/<partition>.txt. If none is given, partition name is used.')
parser.add_argument('--site', '-e', metavar = 'SITE', dest = 'included_sites', nargs = '+', default = [], help = 'List of sites to include. If not specified, all sites in inventory are included. Wildcard is allowed.')
parser.add_argument('--log-level', '-l', metavar = 'LEVEL', dest = 'log_level', default = 'WARNING', help = 'Logging level.')
parser.add_argument('--log-file', '-o', metavar = 'PATH', dest = 'log_file', default = '', help = 'Log output file.')
parser.add_argument('--dry-run', '-D', action = 'store_true', dest = 'dry_run', help = 'Do not make any actual deletion requests or changes to local databases.')
parser.add_argument('--test-run', '-T', action = 'store_true', dest = 'test_run', help = 'Make a test run (results recorded in local database).')

args = parser.parse_args()
sys.argv = []

log_level = getattr(logging, args.log_level.upper())

if args.log_file:
    logging.basicConfig(filename = args.log_file, filemode = 'w', level = log_level)
else:
    logging.basicConfig(level = log_level)

if args.dry_run:
    config.read_only = True

kwd = {}
for cls in ['store', 'site_source', 'dataset_source', 'replica_source']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

inventory_manager = InventoryManager(**kwd)

kwd = {}
for cls in ['deletion']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

transaction_manager = TransactionManager(**kwd)

kwd = {}
for cls in ['store', 'access_history', 'lock']:
    clsname = getattr(args, cls + '_cls')
    if clsname == '':
        kwd[cls + '_cls'] = classes.default_interface[cls]
    else:
        kwd[cls + '_cls'] = getattr(classes, clsname)

demand_manager = DemandManager(**kwd)

history = classes.default_interface['history']()

# Main detox object

detox = Detox(inventory_manager, transaction_manager, demand_manager, history)

# Set up the policies

with open(os.environ['DYNAMO_BASE'] + '/etc/policies.tag') as tag:
    policy_version = tag.read().strip()

if len(args.included_sites) == 0:
    included_sites = re.compile('.*')
else:
    # form a regexp (?:pattern1|pattern2|..)
    included_sites = re.compile('(?:' + '|'.join(map(fnmatch.translate, args.included_sites)) + ')')

partitions = []

for part_spec in args.partitions:
    partdef = part_spec.split(':')

    partition = partdef[0]
    if len(partdef) > 1:
        def_name = partdef[1]
    else:
        def_name = partition

    def_path = os.environ['DYNAMO_BASE'] + '/policies/detox/' + def_name + '.txt'

    partitions.append(partition)

    # currently partition = group except for tapes
    if 'Tape' in partition:
        group_name = partition[:partition.find('Tape')]
        all_sites = [site for site in inventory_manager.sites.values() if site.storage_type == Site.TYPE_MSS]
    else:
        group_name = partition
        all_sites = [site for site in inventory_manager.sites.values() if site.storage_type == Site.TYPE_DISK]

    group = inventory_manager.groups[group_name]
    quotas = dict([(site, site.group_quota(group)) for site in all_sites if included_sites.match(site.name)])

    with open(def_path) as policy_def:
        policy = Policy(partition, quotas, BelongsTo(group), policy_def, policy_version)

    detox.set_policy(policy)

if args.force_inventory_update:
    inventory_manager.update()

for partition in partitions:
    detox.run(partition = partition, is_test = args.test_run)
